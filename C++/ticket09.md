## Билет 09 "Исключения — основы"
Автор: Чистякова Полина
### Предусловия и постусловия конструктора и деструктора, инвариант объекта

Инвариант объекта - то, что определяет его корректное состояние
Иными словами что-то, что всегда верно про этот объект.

Пример: ```uniq_ptr<T> a``` - владеет указателем, на основе которого он построен. Никто больше этим указателем не владеет.

Как понятно, пока объект живёт - инвариант выполняется. Отсюда вытекают некоторые уловия:

	Постусловие конструктора - инвариант выполняется
	Предусловие конструктора - поля сконструированны
	Постуловие деструктора - объект корректно уничтожен
	Предусловеи деструктора - инвариант выполняется
### Как отличить "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать), разные стратегии обработки для двух видов ошибок

Существует 2 типа ошибок - они указаны в заголовке.
Отличаются они тем, что первые совершил программист и сам находит (путём отладки кода), а вторые от него совсем не зависят (например, обращение к несуществующему файлу) и с ними надо научиться справляться.

Первые ошибки обрабатываются просто - можно поставить `assert`'ы и просто ронять программу, когда они происходят, чтобы программист сразу понимал, что что-то не так.

Со вторым типом ошибок сложнее - так просто уже не поступить, надо сообщить пользователю, что же произошло, и, возможно, сохранить какие-то результаты.

Для этого существует несколько стратегий:
 * Вывод сообщения об ошибке сразу, как её встретили:
    ```C++
    void read_people() {
       File *f = fopen(filename, "r");
       if (!f) {
          printf("сообщение об ошибке");
          return;
       }
    }
    ```
    Проблема этого подхода - не всегда надо сразу писать в стандартный поток вывода (например, мы хотим выводить ошибку как-тов графическом интерфейсе)
    Иногда хочется ошибку обработать не тут (например, ошибка на сервере, а сказать надо что-то тому, кто туда обратился)
 * Возвращать код ошибки
   ```C++
   int sqlite3_open(const char *fname, sqlite3A *out); // Возвращаемое значение - код ошибки. Второй параметр - указатель на результат работы функции
   ```
   Проблема конкретно этогоподхода сразу видна - надо знать все значения кода, что не очень удобно для программста
 * Почти возвращение кода ошибки - возвращать структуру, в которой может лежать значение OK или Error
   *пример на Rust'е*
   ```Rust
     fn Read_people() -> Result<People, String> {
        match open() {
           OK(f) -> {...}
           Err(err) -> return Err(err);
        }
     }
     let f = try!(open());
   ```
   Здесь Result - как раз такая стурктурка. Если ошибок нет, она ыернёт значение OK или значение Err в противном случае.
   Проблема этого подхода - каждая функция очень аккуратно прощупывает остальные, всегда готова поймать исключение и, если сама не может её обработать, прокинуть дальше.
 * Кидать исключения
   ```C++
   std::vector<int> read_vector() {
      int n;
      if (!(cin >> n)){
         throw invalid_vector_format();
      }
   }
   
   try {
      read_vector();
   } catch ( invalid_vector_format() &err ) { /* обработка ошибки */ )
   ```
   Данный подход - просто goto решение проблемы

### Примеры обработки разных видов ошибок без исключений: assert, коды возврата
### Исключения: try, catch, throw (синтаксис, и для новых исключений, и для перебрасывания "текущего"), где что ставить для обработки ошибок
### Вложенные try/catch, несколько catch подряд и почему важно ловить по ссылке
### Stack unwinding (раскрутка стэка) и уничтожение локальных ресурсов
### Идиома Resource Acquisition Is Initialization (RAII)
### Примеры исключений из стандартной библиотеки (std::exception и его наследники, bad_alloc)

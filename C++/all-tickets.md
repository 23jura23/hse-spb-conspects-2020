## Билет 01
Автор: <Имя Фамилия>
## Билет 02
Автор: Носивской Влад

* Зачем: во избежание коллизий. Например, пишем клиент-сервер, класс User есть и у клиента, и у сервера. Для этого заведем namespace client и namespace server. Теперь обращение client::User и server::User соответственно.

* Еще немного про мотивацию:
    * Можно использовать вложенные классы:

        ```C++
        class Database {
        public:
            class User { ... };
        };
        ```

        ```C++
        class Application {
        public:
            class User { ... };
            static Database connectToDb() { ... }
        };
        ```

        Здесь Database::User и Application::User - разные классы. Есть минусы: нужно писать много static-ов и в разных файлах использовать разные классы, либо заводить один God object, который содержит все функции и переменные со всех файлов. 
        
        Зачем здесь написан static для функции connectToDb? static функции как члены класса - это функции, которые не требуют наличия экземпляра класса для вызова (в данном случае мы не обязаны иметь экземпляр класса Application для вызова функции connectToDb).

    * А можно использовать namespaces:
        
        ```C++
        namespace database {
        class Database {
        public:
            class User { ... };
        };
        } // namespace database

        namespace application {
        class User { ... };
        database::Database connectToDb() { ... }
        } namespace application
        ```
* Немного про стиль при использовании namespace:
    * Обычно в одном файле один namespace. Внутри пишется без отступов (см. пример выше)
    * Имя в snake_case
    * namespace можно переоткрывать (в отличие от классов), в том числе в разных файлах. При этом содержимое конкатенируется. 
    * Если пишете библиотеку - хороший тон обернуть ее в namespace, а дальше творить в ней что угодно.
    * Заглянуть внутрь это ::, как у классов.

* Вложенные пространства имен.
    ```C++
    namespace database {
        namespace internal {
            void foo();
            void bar();
            struct Foo {};
        } // namespace internal
        struct User {};
    } // namespace database
    ```

    Начиная с С++11 можно писать так:

    ```C++
    namespace database::internal {
        void foo();
        void bar();
    } // namespace database::internal
    ```

    Чтобы обратиться к глобальному пространству имен, обратитесь будто к безымянному пространству:

    ```C++
    int foo;
    namespace bar {
        int foo;
        void some() {
            ::foo = 0; // Изменилось значение переменной, которая объявлена в глобальном пространстве имен.
        }
    } 
    ```

* Анонимное пространство имен.
    * Вспомним для начала, что такое internal linkage.
        
        header.hpp

        ```C++
        static int var = 82; // Передаю привет Гимназии №82 города Краснодара
        ```

        file1.hpp

        ```C++
        #include "header.hpp"

        void foo() { var = 239; }
        ```

        main.cpp
        ```C++
        #include <iostream>
        
        #include "header.hpp"
        #include "file1.hpp"

        int main() {
            foo();
            std::cout << var << std::endl;
        }
        ```

        Такая программа на выходе выдаст 82, а не 239, так как переменная var объявлялась как static, поэтому в каждом файле, где ее подключили, она своя.

    * Выше был показан сишный подход, в плюсах решили, что для internal linkage будут использовать анонимные пространства имен. А именно, для реализации того, что показано выше, в плюсах мы напишем:

        header.cpp

        ```C++
        namespace {

        int var = 82;

        }
        ```

        Теперь в плюсах не принято писать static-функции, их принято оборачивать в анонимные пространства имен.

* Про typedef и using, а главное - про отличие между ними.

    typedef пришел к нам из Си и означает он синоним имени. using же протаскивает имя.

    Например, можно сказать typedef int score_t; чтобы использовать score_t в коде, это будет псевдоним для int.

    * Вне контекста пространств имен typedef проигрывает using-у, так как ему очень плохо дается работа с шаблонами. Пример:

        ```C++
        template<typename T>
        using myAllocList = std::list<T, myAlloc<T>>;

        myAllocList<Object> ml;
        ```

        С typedef-ом написать подобный код будет больно и сложно (но все же возможно, пусть и использование усложнится).

    * В контексте пространств имен using позволяет протащить имя в точку.

        ```C++
        using database::Database;
        ```

    * Еще можно протаскивать целиком все имена из пространства имен:

        ```C++
        using namespace database;
        ```

        Здесь нужно быть очень аккуратным и уверенным, что не будет коллизий с именами. Поэтому не стоит писать в коде using namespace std; (привет контестам), ведь мы не знаем все имена из стандартной библиотеки. Например, там лежат функции left и right, а назвать так переменную иногда может хотеться. 

        Стоит отметить, что использование using namespace внутри .h/.hpp файлов идея сомнительная. Пользователь может добавить хедер и надеяться, что коллизий не будет.


## Билет 03
Автор: <Имя Фамилия>
## Билет 04
Автор: <Имя Фамилия>
## Билет 05
Автор: <Имя Фамилия>
## Билет 06
Автор: <Имя Фамилия>
## Билет 07
Автор: <Имя Фамилия>
## Билет 08
Автор: <Имя Фамилия>
## Билет 09
Автор: <Имя Фамилия>
## Билет 10
Автор: <Имя Фамилия>
## Билет 11
Автор: <Имя Фамилия>
## Билет 12
Автор: <Имя Фамилия>
## Билет 13
Автор: Кирилл Карнаухов

### Объект-функтор
Функтором называется класс (или структура) с перегруженным `operator()`. Могут применяться также, как и функции, однако имеют преимущества. Например, хотим посортировать массив по компаратору `a[i] * x`, где `x` — константа. Для обычной функции-компаратора пришлось бы заводить отдельную глобальную константу, что не очень хорошо. Однако в функторе мы можем хранить `x`, как поле класса. Возможная реализация:
```cpp
struct Comparator {
    int x;
    bool operator()(int a, int b) {
        return a * x < b * x;
    }
};
```
Теперь можно использовать этот функтор, например, для сортировки такого вида:
```cpp
template<typename T, typename Cmp>
void sort(Array<T>& array, Cmp cmp) {...}
```
Плюсом ко всему является то, что нет виртуальных вызовов.

### Применение в алгоритмах 
Функторы имеют огромное применение в `std::algorithm`. Например, имея функтор из предыдущего пункта, можно:
```cpp
std::vector<int> arr = {...};
std::sort(arr.begin(), arr.end(), Comparator{1}); //сортировка по возрастанию
std::sort(arr.begin(), arr.end(), Comparator{-1}); //сортировка по убыванию
```
Сюда можно передавать все, отчего можно вызвать `()` без аргументов. 

Примечание: в таких применениях функция сравнения должна быть транзитивной, иначе будет `Runtime Error`.

### Функторы, как компараторы в ассоциативных контейнерах
По умолчанию, `std::set` хранит значения по возрастанию. Хотим хранить, например, `int` по убыванию. Напишем компаратор:
```cpp
struct Comparator {
	bool operator()(int a, int b) {
		return a > b;
	}
};
```
Тогда, если написать `std::set<int, Comparator>`, то контейнер будет хранить ключи по убыванию. 

В общем, случае, нужно передавать функтор, который для `(a, b)` возвращает `true`, когда `a` должен идти *не позже* `b`. 

То же самое можно делать с `std::map` и другими ассоциативными контейнерами. 

Примечание: верно то же самое, что функция должна быть транзитивной. 

### Лямбды
Все это, конечно, очень круто, но иногда нам нужно использовать функтор всего в одном месте, и не как-то не хочется для этого создавать отдельный класс. Или нам хочется создать функцию внутри другой функции. Для этого придумали лямбды. Синтакис такой:
```cpp
auto func = [](int a, int b) {
	return a + b;
};
```
По сути, лямбды — это синтаксический сахар. На самом деле, это просто функтор с неизвестным типом. Применение:
```cpp
std::sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); //сортировка по убыванию
```
По умолчанию, в лямбдах нельзя ничего использовать, помимо глобальных переменных. Чтобы была возможность брать переменные из области видимости, есть так называемые захваты:
```cpp
int x = 100;

auto cmp1 = [x](int a, int b) { return a * x < b * x; }; //захват по значению (то есть значение x скопируется)
auto cmp2 = [&x](int a, int b) { return a * x < b * x; }; //захват по ссылке
auto cmp3 = [=](int a, int b, int c, std::string d) { ... }; //захват всей области видимости по значению
auto cmp4 = [&](int a, int b, float f) { ... }; //захват всей области видимости по ссылке

struct smth {
	void func() {
		auto f = [this]() { ... }; //захват всего экземпляра класса
	}
};
``` 

### Подробности лямбды
Как уже говорилось, нельзя явным образом получить тип лямбды. Однако, если мы хотим указать тип, например, для шаблонов, то можно использовать `decltype`.

Лямбда превращается в анонимный класс с `operator()`. 

Также, комппилятор все оптимизирует на этапе компиляции.

### mutable для лямбды
По умолчанию, лямбда создает функтор с `operator()`, который является `const-qualified`. Но иногда нам все-таки хочется менять переменные внутри оператора. Для этого можно написать `mutable`, то есть:
```cpp
int x = 10;
auto func = [&x](int a, int b) mutable {
	x--;
	return a * x < b * x;
};
```

### Возвращаемое значение
Лямбда сама узнает, какое возвращаемое значение у `operator()`. Например, здесь это `int`:
```cpp
auto func = [](int x) { return x * x; };
```
Если функция возвращает несколько значений, то компилятор смотрит на первый `return`. То есть следующий код **не** скомпилируется:
```cpp
auto func = [](int x, double y) {
	if (x > 0) {
		return 0;
	} else {
		return y;
	}
};
```
Это происходит, потому что компилятор не понимает, что именно мы хотим вернуть. Однако, можно использовать касты. 

Также можно явно указать тип возвращаемого значения:
```cpp
auto func = [](int a, double y) -> double { ... };
```

### Шаблонные параметры
Пока полноценные шаблоны для лямбд в C++ не завезли, но есть `auto`.  Например, можно так:
```cpp
std::vector<std::string> array = { ... };
std::sort(array.begin(), array.end(), [](const auto &fir, const auto &sec) {
	return a.length() < b.length();
});
```
Компилятор сам поймет, какие типы у аргументов. 

### Отличия от `std::function`
Внутри `std::function` хранится указатель на выделенный объект на куче, у которого нужно вызвать `()`. Можно ли хранить лямбды в `std::function`? Да, можно. Нужно ли? Нет, нужно пытаться этого избегать.

Проблема в том, что вызов метода у `std::function` — это виртуальный вызов и он не всегда будет соптимизирован. В то же время, лямбда не имеет виртульаных вызовов. Из-за этого `std::function` может работать сильно медленнее обычной лямбды.

Если хотите сохранить лямбду, можете сохранить ее в шаблон.

## Билет 14
Автор: <Имя Фамилия>
## Билет 15
Автор: <Имя Фамилия>
## Билет 16
Автор: <Имя Фамилия>
## Билет 17
Автор: <Имя Фамилия>
## Билет 18
Автор: <Имя Фамилия>
## Билет 19
Автор: <Имя Фамилия>
## Билет 20
Автор: <Имя Фамилия>
## Билет 21
Автор: <Имя Фамилия>
## Билет 22
Автор: <Имя Фамилия>
## Билет 23
Автор: <Имя Фамилия>
## Билет 24
Автор: Пётр Сурков

### STL

* Containers libary
* Iterators libary
* Algoritms libary

Этот билет — Containers libary. В следующих билетах есть подробнее про каждый из видов контейнеров в нём. 

А ещё тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в `std::`

### Containers libary
Хранит объекты и управляет их временем жизни.

Должен быть

* Деструктор
* Хотя бы некоторые из конструкторов (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов)
* Обычно должны быть операторы присванивания (копирования, перемещения)

Контейнеры инвариантны по типам: `vector<Base*>` и `vector<Derived*>` - независимые контейнеры. Скопировать второй в первый не получится.

#### Аллокатор

Памятью управляет аллокатор - шаблонный класс, умеющий выделять, удалять память, инициализировать и удалять объект. 

Обычно используется `std::allocator`, он вызывает `new/delete`, которые можно [перегружать](https://habr.com/ru/post/490640/).

Аллокатор - сложный объект. должен уметь выделять не только `T`. Например, в `list<>` нужно уметь выделять внутренний тип (структуру с `T` и указателями на следующий элемент).

К тому же, до C++11 аллокаторы не могли иметь глобального состояния.

Из-за этого есть специфичные требования к написанию собственных аллокаторов.

#### Сложность и гарантии исключения
Стандарт обещает какое-то время работы. Например, копирование `vector<T>` происходит за `O(n)` копирований `T`. 

Базовая гарантия есть всегда, про строгую каждой операции надо читать в стандарте. Но если move T кидает исключения, то многие строгие гарантии рушатся. 

#### Виды контейнеров

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

#### Стандартные операции, есть всегда:

* Конструктор по умолчанию `O(1)`
* Конструктор перемещения `O(n)` (при копировании `T` за `O(1)`)
* `a.swap(b)`, `swap(a,b)` за константу для всех, кроме `std::array`
* `.empty()` (константа)
* `.size()` (константа, даже у списка)
* Конструктор копирования, если `CopyInsertable` (есть конструктор копирования у `T`):
* `==`/`!=`, если объекты можно сравнивать на `==`/`!=`:    
* Для обобщённого программирования:
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`

#### Некоторые из гарантий исключений
##### noexcept
* `erase` (если только не бросит исключение move/copy оператор/конструктор в `vector`/`deque`)/`clear`/`swap`
* `pop_back`/`pop_front` (если есть)

##### Строгая гарантия
* `insert`/`emplace` (если вставляет один элемент, а не много сразу; и то только если с нужного конца, см. `vector`/`deque`)
* `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)


#### Range-based for
Синтаксический сахар, разворачивается как 
```cpp
for (DECL : EXPR) BODY
{
    auto range = EXPR;
    auto begin = std::begin(range);
    auto end = std::begin(end);
    for (auto it = begin; it != end; ++it) {
        DECL = *it;
        BODY
    }
}
```
Функции `std::begin`/`std::end` вызывают внутренние `begin`/`end`, но перегружены для обычных массивов.

Есть тонкость. В `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, но `bar()` живёт. 

[Пример](https://cppinsights.io/) развёртки сахара.

Не стоит удалять/добавлять элементы в контейнер, внутри range-based for по нему.

#### Удаление, Инвалидация
Функция `.erase` возвращает итератор на элемент, который теперь занимает место первого удалённого элемента, либо `end()` при его отсутствии.

Про инвалидацию подробно читать в билете №28 про итераторы. ## Билет 25
Автор: <Имя Фамилия>
## Билет 26
Автор: <Имя Фамилия>
## Билет 27
Автор: <Имя Фамилия>
## Билет 28
Автор: <Имя Фамилия>
## Билет 29
Автор: <Имя Фамилия>
## Билет 30
Автор: <Имя Фамилия>
## Билет 31
Автор: Александр Морозов
## Билет 32
Автор: <Имя Фамилия>
## Билет 33
Автор: <Имя Фамилия>
## Билет 34
Автор: Александр Морозов
## Билет 35
Автор: <Имя Фамилия>

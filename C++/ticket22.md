## Билет 22
Автор: Тарасов Денис

* ### Правило нуля
  Если все поля нашего класса примитивные типы или типы, поддерживающие move-семантику (например вместо обычных указателей использовать `unique_ptr` из стандартной библиотеки, где у всего поддерживается move-семантика), то необходимости в каких-либо дополнительных действиях нет. Не нужно каким-либо специальным образом переопределять деструктор, конструктор копирования/перемещения, оператор присвоения копированием/оператор присваивания перемещением, их можно оставить стандартными, если только вы не хотите делать что-то специфическое.


* ### Ref-qualifier
  В сигнатуры методов можно добавлять следующие модификаторы:

  * `&` - позволяет вызывать метод только от lvalue объектов.

  * `&&` - позволяет вызывать метод только от rvalue объектов.

  Примеры:

  * Например у стека не имеет смысла вызывать метод `push` от rvalue объекта, который просто умрет после этого.
  ```C++
  struct Stack {
      ..
      void push (const T&) &;
  }
  ```

  * В `lab_15` у нас создавалась цепочка из временных объектов, другого использования методов класса `enumerator` не предполагалось.
  ```C++
  auto drop(int count) && noexcept {
      return drop_enumerator<T>(*this, count);
  }
  ```

  * Для вектора, например, можно сделать 3 перегрузки `operator[]`
  ```C++
  struct vector {
      const T& operator[](size_t) const; // T var1 = v[i];
      T& operator[](size_t) &; // v[i] = var2;
      T&& operator[](size_t) &&; // Объект умрет, поэтому можно соптимизировать
          // и сделать move из нужного элемента.
  }
  ```

* ### Типичная реализация конструктора

  * Простой пример
  ```C++
  struct Person {
      Person(std::string name) : name_(std::move(name)) {
        ..
      }
      std::string name_;
    }
  ```
  * Могут быть и другие методы, например тот же push у стека от временного значения.
  ```C++
  struct Stack {
      ..
      void push (T &&val) & {
          ..
          new (data_ + size) T(std::move(val));
      }
  }
  ```

* ### Rvalue-ссылки
  Обычные ссылки привязываются только к lvalue значениям, константные к чему угодно. В C++11 появляются rvalue-ссылки: `Foo &&x = foo();`. Они привязываются только к rvalue (xvalue, prvalue).

* ### Правила привязывания ссылок
  * `Foo &f = ..; // glvalue, CE для prvalue`
  * `const Foo &f = ..; // что угодно, попытается продлить жизнь`
  * `Foo &&f = ..; // rvalue`

  После привязки ссылки во всех случаях `f` станет lvalue. Все то же самое для аргументов функций.

  `const Foo &&f` может привизаться только к `rvalue`, при этом из-за константности из нее нельзя сделать move, который мы обычно применяем к rvalue-ссылкам. Поэтому конструкция бесполезна, но есть какие-то специфические случаи, описаные [здесь](https://www.codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/).


* ### Move-конструктор, оператор перемещающего присваивания
  *  Move-конструктор и оператор перемещающего присваивания это просто новые перегрузки.
  ```C++
  struct Foo {
      ..
      Foo (Foo &&other) noexcept : data1_(std::move(other.data1_)),
       data2_(std::move(other.data2_)){
          ..
          /* Сделали что-то нужное для нового объекта и
             перевели other в какое-то новое состояние. */
      }
      Foo & operator=(Foo &&other) noexcept {
          // Почистили себя
          ..
          data1_ = std::move(other.data1_);
          data2_ = std::move(other.data2_);
          // Поменяли состояние other
          ..
          return *this;
      }
      std::unique_ptr<T> data1_, data2_;
  }
  ```
  При вызове конструктора копирования `stack s(VAL);` вызовется более подходящий в зависимости от категории `VAL`, у move приоритет больше, т.к. он более специфичен.

  * Нам очень хочется иметь гарантию исключений, т.к. после move состояние объектов нам не известно и в случае ошибки скорее всего не получится что-либо гарантировать. Например, `std::vector` требует от move-конструктора `noexcept`. Более подробно можно посмотреть [здесь](https://xinhuang.github.io/posts/2013-12-31-when-to-use-noexcept-and-when-to-not.html).

* ### Правило пяти
  После появления move-семантики знакомое нам правило трех превратилось в правило пяти: к конструктору копирования, оператору присваивания и деструктору добавились конструктор перемещения и оператор присваивания перемещением.
